# AUTOGENERATED! DO NOT EDIT! File to edit: 03_Tracking.ipynb (unless otherwise specified).

__all__ = ['get_py_files', 'get_cells_one_nb', 'write_code_cell', 'py_to_nb', 'get_module_text', 'write_module_text',
           'clear_all_modules', 'simple_export_one_nb', 'simple_export_all_nb', 'create', 'append', 'delete',
           'print_keys', 'get_stat', 'get_stats', 'print_best', 'graph_stat', 'graph_stats']

# Cell
import os, json, copy
from pathlib import Path
from nbdev.export import read_nb

# Cell
def get_py_files(path):
    '''Get all py files in a direcotry'''
    return [f for f in os.listdir(path) if f[-3:] == '.py']

# Cell
def get_cells_one_nb(path,file_name):
    '''For py file in path get a return list of strings
    Each item in list will corrospond to the contents of a cell in a notebook'''

    file = open(path/file_name)
    Lines = file.readlines()

    split_flag = True
    cells = [[]]
    i = 0

    for j,line in enumerate(Lines):
        split_criteria = line.startswith(('import ','from ','def ','class ','@',"if __name__ == '__main__':"))

        if split_flag != split_criteria:  cells[i].append(line)

        if split_criteria and split_flag:
            i+=1
            cells.append([])
            cells[i].append('#export\n')
            cells[i].append(line)
            split_flag = False

        if not split_flag and not split_criteria: split_flag = True

    return cells

# Cell
def write_code_cell(code):
    '''take a piece of code and write it to a code cell
    '''
    out = {"cell_type": "code","execution_count": 0,"metadata": {},"outputs": [],"source": []}
    out["source"] = code
    return out

# Cell
def py_to_nb(py_path,nb_path):
    '''Write jupyter notebooks based on py files in py_path'''
    if not os.path.exists(nb_path): os.makedirs(nb_path)

    files = get_py_files(py_path)

    nb = {"cells": [],"metadata": {},"nbformat": 4, "nbformat_minor": 4}
    for i,file in enumerate(files):
        out_file = f'{file[:-2]}ipynb'; print(f'writing {out_file}') # change extension
        cells = get_cells_one_nb(py_path,files[i]) # get cells that should be written
        for cell in cells: nb["cells"].append(write_code_cell(cell)) # add cells to dict
        with open(nb_path/out_file, 'w') as file: file.write(json.dumps(nb)) # write dict to json

# Cell
def get_module_text(notebook_path):
    '''Read ipynb file and get all code from code cells with #export or # export at the beginning'''
    nb = read_nb(notebook_path)
    module = ''
    for cell in nb['cells']:
        if cell['cell_type']=='code':
            if cell['source'].startswith('#export') or cell['source'].startswith('# export'):
                module = module + cell['source'] + '\n\n'
    return module

# Cell
def write_module_text(module_text,notebook_name,lib_path=Path('./src')):
    '''Write module_text to lib_path/notebook_name as .py file'''
    if not os.path.exists(lib_path): os.makedirs(lib_path)
    module_name = (str(notebook_name)[:-5] + 'py').lstrip('0123456789.- _').replace('-','_')
    f = open(lib_path/module_name, "w")
    f.write(module_text)
    f.close()
    print(f'Converted {lib_path/module_name}')

# Cell
def clear_all_modules(lib_path=Path('./src')):
    '''Clear all .py files from lib_path to reset your .py exported files'''
    if not os.path.exists(lib_path): os.makedirs(lib_path)
    filelist = [ f for f in os.listdir(lib_path) if f.endswith('.py')]
    for f in filelist: os.remove(os.path.join(lib_path, f))
    print('========= Modules Cleared ==========')

# Cell
def simple_export_one_nb(nb_path,lib_path = Path('./src')):
    '''clear_all_modules in lib_path
    for each notebook in nbs_path get_module_text and write_module_text to lib_path
    All .py files in lib_path will be removed and replaced
    '''
    module_text = get_module_text(nb_path)
    if module_text == '': print(f'Nothing to Convert {lib_path/nb_path}')
    else: write_module_text(module_text,nb_path,lib_path)

# Cell
def simple_export_all_nb(nbs_path = Path('.'),lib_path = Path('./src'),clear=False):
    '''clear_all_modules in lib_path if clear=True
     for each notebook in nbs_path get_module_text and write_module_text to lib_path
     All .py files in lib_path will be removed and replaced
    '''
    nbs = [nbs_path/n for n in  os.listdir(nbs_path) if n.endswith('.ipynb')]
    if clear: clear_all_modules(lib_path)
    for i in range(len(nbs)): simple_export_one_nb(nbs[i],lib_path)

# Cell
import shelve
import matplotlib.pyplot as plt
import os
from fastcore.foundation import *
import numpy as np

# Cell
def create(filename,keys):
  with shelve.open(filename) as d:
    if type(keys) == str: d[keys] = L()
    else:
        for key in keys: d[key] = L()

# Cell
def append(filename,new_dict,key='exp'):
    '''Append a new_dict to list store in key - create db if needed'''
    if not os.path.exists(filename): create(filename,key)
    with shelve.open(filename) as d:
        if key not in list(d.keys()): d[key] = L()
        tmp = d[key]
        tmp.append(new_dict)
        d['exp'] = tmp

# Cell
def delete(filename,exp_num,key='exp'):
    '''delete an item from list stored in key'''
    with shelve.open(filename) as d:
        tmp = d[key]
        if type(exp) == int:
            tmp.pop(exp_num)
        if type(exp) == str:
            for i,e in eumerate(tmp):
              if e['name'] == name: tmp.pop(i)
        d[key] = tmp

# Cell
def print_keys(filename,last_only=True, with_type=False, key='exp'):
    with shelve.open(filename) as d:
        if last_only and not with_type: print(list(d[key][-1].keys()))
        if last_only and with_type: print({k:type(v) for k,v in d['exp'][-1].items()})
        if not last_only and not with_type:
            a = L()
            for o in d['exp']: a = a + L(o.keys())
            a = a.unique()
            print(a)
        if not last_only and with_type:
            a = {}
            for o in d['exp']: a.update({k:type(v) for k,v in o.items()})
            print(a)

# Cell
def get_stat(filename,exp_num,stat,key='exp',display=True):
    '''get a specific stat (ie loss) from key for a given expirament
    Goes well with partial
    '''
    with shelve.open(filename) as d:
      if display: print(f'd[{key}][{exp_num}][{stat}]: {d[key][exp_num][stat]}')
      return (f'd[{key}][{exp_num}][{stat}]',d[key][exp_num][stat])

# Cell
def get_stats(filename,exp_num,stats,key='exp',display=True):
    return [get_stat(filename,exp_num,stat,key,display) for stat in stats]

# Cell
def print_best(filename,stat,best='min', key='exp'):
    with shelve.open(filename) as d: exps = len(d[key])
    if best == 'min':
        out = (np.inf,None)
        for i in range(exps):
          a,b = get_stat(filename,i,stat,display=False)
          if min(b) < out[0]: out = (min(b),i)
    if best == 'max':
        out = (-np.inf,None)
        for i in range(exps):
          a,b = get_stat(filename,i,stat,display=False)
          if max(b) > out[0]: out = (max(b),i)

    print(f'{stat} {best} value = {out[0]} | best idx = {out[1]-exps}')

# Cell
def graph_stat(filename,stat,idxs=[-1,-2,-3], key='exp',name='name',figsize=(12,6)):
    with shelve.open(filename) as d:
        fig,ax = plt.subplots(figsize=figsize)
        for e in L(d[key])[idxs]:
            try:
              vals = e[stat]
              ax.plot(range(len(e[stat])),e[stat],label=e[name])
              ax.legend();ax.set_title(f'{stat}')
            except:
              print(f'Unable to plot {stat} for {e[name]}')

def graph_stats(filename,stats,idxs=[-1,-2,-3],key='exp',name='name',figsize=(12,6)):
    for stat in stats:
        graph_stat(filename,stat,idxs,key,name,figsize)